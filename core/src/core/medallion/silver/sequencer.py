from typing import Any, Dict, List, Optional, Tuple

import sqlglot
from sqlglot import exp

from core.medallion.base.sequencer import _BaseSequencer
from core.constants.medallion import Layer
from core.types.metadata import QueryMetadata, DiscoveredMethod
from core.settings import get_settings
from core.operations import BaseOperation
from copy import deepcopy  


class SilverTransformationSequencer(_BaseSequencer):
    
    def __init__(self, sql_dialect: str = "tsql"):
        """Initialize the Silver Transformation sequencer.
        
        Args:
            sql_dialect: SQL dialect for parsing (tsql for Synapse, spark for Databricks, etc.)
        """
        settings = get_settings()
        super().__init__(settings)
        self.layer = Layer.SILVER
        # Override sql_dialect if provided
        if sql_dialect:
            self.sql_dialect = sql_dialect
    
    def get_layer_name(self) -> str:
        """Return the layer name for this sequencer.
        
        Returns:
            'silver' - the silver layer identifier
        """
        return self.layer.value
    
    def get_obj_name(self) -> str:
        """Get unique object name for Silver transformation sequencer.
        
        Returns the sp_name from the silver metadata if available,
        otherwise falls back to class name.
        
        Returns:
            sp_name from metadata or class name
        """
        metadata = self._get_class_metadata()
        if metadata and 'sp_name' in metadata:
            return metadata['sp_name']
        
        return super().get_obj_name()
    
    def _get_class_metadata_attribute(self) -> Optional[str]:
        """Get the class-level metadata attribute name for Silver Transformation sequencer.
        
        Silver Transformation sequencer uses @silver_metadata decorator at class level.
        
        Returns:
            '_silver_metadata' - the attribute name for class metadata
        """
        return '_silver_metadata'
    
    
    def _handle_null_result(self, metadata: QueryMetadata) -> Optional[str]:
        """Handle filter-based dimensions that return None.
        
        Auto-generates enum queries for Silver dimension tables with filter metadata.
        
        Args:
            metadata: Query metadata from the decorator
            
        Returns:
            Optional[str]: Generated enum query or None if not applicable
        """
        if hasattr(metadata, 'filter') and metadata.filter:
            return self._generate_enum_query(metadata)
        return None
    
    def _generate_enum_query(self, metadata: QueryMetadata) -> str:
        """Generate enum query for filter-based dimensions.
        
        Filter-based dimensions are Silver layer specific and pull
        enum values from the bronze.Enumeration table.
        
        Args:
            metadata: QueryMetadata with filter and table_name fields
            
        Returns:
            str: Auto-generated SQL query for enum lookup
        """
        table_name = metadata.table_name
        enum_name = metadata.filter
        from query_builder.factory import get_query_builder

        query_builder = get_query_builder()

        enum_table = query_builder.fully_qualified_name("bronze", "Enumeration")
        return f"""SELECT 
                EnumValue AS {table_name}, 
                EnumValueID AS {table_name}ID, 
                CURRENT_TIMESTAMP AS _CreatedDate, 
                CURRENT_TIMESTAMP AS _ModifiedDate  
            FROM {enum_table} 
            WHERE Enum = '{enum_name}'"""
    
    def _transform_query_result(self, sql: str, metadata: QueryMetadata) -> Tuple[str, QueryMetadata]:
        """Transform Detail tables in temp schema to Silver format.
        
        Automatically applies silver layer transformations (null handling and default row)
        to queries targeting Detail tables in the temp schema.
        
        Args:
            sql: The SQL query string generated by the method
            metadata: Query metadata from the decorator
            
        Returns:
            str: Transformed SQL for Detail tables in temp schema, unchanged otherwise
        """
        if (metadata.table_name and  metadata.table_name.endswith('Detail') and  metadata.schema_name == 'temp'):
            self.logger.info(
                f"Applying silver transformation to Detail table",
                table=metadata.table_name,
                schema=metadata.schema_name
            )
            transformed_metadata = deepcopy(metadata)
            transformed_metadata.schema_name = 'silver'
            transformed_metadata.table_name = metadata.table_name.replace('Detail', '')
            
            return self.transform_detail_to_silver(sql), transformed_metadata

        return sql, metadata

    def transform_detail_to_silver(self, detail_query: str) -> str:
        """
        Transform detail query to include null handling and default row using SQLGlot.
        
        This method takes a detail table query (like Customer_FactDetail) and transforms it
        to create a silver table directly, applying null handling and adding a default row.
        
        Args:
            detail_query: The final detail SELECT query from transformation
            table_name: Optional table name for custom default handling
            
        Returns:
            Transformed SELECT query ready for direct silver table creation
            
        Example:
            >>> sequencer = SilverTransformationSequencer()
            >>> detail_sql = "SELECT CustomerKey, CreditLimit FROM temp.Stage"
            >>> silver_sql = sequencer.transform_detail_to_silver(detail_sql)
            >>> # Returns query with ISNULL handling and default row
        """
        # Parse the detail query using SQLGlot
        try:
            ast = sqlglot.parse_one(detail_query, dialect=self.sql_dialect)
        except Exception as e:
            raise ValueError(f"Failed to parse SQL query: {e}")
        
        # Find the SELECT clause
        select = ast.find(exp.Select)
        if not select:
            raise ValueError("Could not find SELECT clause in query")
        
        null_handled_cols = []
        default_values = []
        
        # Process each column in the SELECT
        for expr in select.expressions:
            # Get column alias (the output column name)
            if isinstance(expr, exp.Alias):
                col_name = expr.alias
                source_expr = expr.this
            elif isinstance(expr, exp.Column):
                col_name = expr.name
                source_expr = expr
            else:
                # Complex expression without alias - generate a name
                col_name = expr.sql(dialect=self.sql_dialect).replace(' ', '_')[:50]
                source_expr = expr
            
            # Determine null handling based on column name/type
            null_expr, default_val = self._get_null_handling(col_name, source_expr)
            
            null_handled_cols.append(f"{null_expr} AS [{col_name}]")
            default_values.append(f"{default_val} AS [{col_name}]")
        
        # Build the transformed query with CTEs
        null_handled_str = ',\n        '.join(null_handled_cols)
        default_values_str = ', '.join(default_values)
        
        transformed_query = f"""WITH detail_data AS (
                    {detail_query}
                ),
                transformed_data AS (
                    SELECT 
                        {null_handled_str}
                    FROM detail_data
                )
                SELECT * FROM transformed_data
                UNION ALL
                SELECT {default_values_str}"""
        
        return transformed_query
    
    def _get_null_handling(self, col_name: str, source_expr: exp.Expression) -> Tuple[str, str]:
        """
        Determine null handling and default value for a column.
        
        Args:
            col_name: Column name/alias
            source_expr: SQLGlot expression for the column
            
        Returns:
            Tuple of (null_handling_expression, default_value)
        """
        # Check if already has ISNULL/COALESCE - don't double-wrap
        if isinstance(source_expr, exp.Coalesce):
            # Already has null handling, extract the default
            if len(source_expr.expressions) > 1:
                default = source_expr.expressions[1].sql(dialect=self.sql_dialect)
                return (f"[{col_name}]", default)
        
        # Determine type based on column name patterns
        col_lower = col_name.lower()
        
        # RecID and SourceID special cases - check first before general ID check
        if col_name in ['_RecID', '_SourceID', 'RecID', 'SourceID', '_RecId', '_SourceId']:
            return (f"ISNULL([{col_name}], 0)", "0")
        
        # Keys get -1
        elif col_name.endswith('Key') or col_name.endswith('KeyID'):
            return (f"ISNULL([{col_name}], -1)", "-1")
        
        # IDs that are likely strings
        elif col_name.endswith('ID') and not col_name.endswith('Key'):
            # Check if it's a numeric ID based on common patterns
            if any(x in col_lower for x in ['status', 'credit', 'balance']):
                return (f"ISNULL([{col_name}], -1)", "-1")
            else:
                return (f"ISNULL([{col_name}], '')", "''")
        
        # Dates get 1900-01-01
        elif col_name.endswith('Date') or '_date' in col_lower:
            return (f"ISNULL([{col_name}], '1900-01-01')", "'1900-01-01'")
        
        # Numeric columns get 0
        elif any(x in col_lower for x in ['amount', 'balance', 'credit', 'limit', 'quantity', 
                                           'count', 'total', 'price', 'cost', 'rate']):
            return (f"ISNULL([{col_name}], 0)", "0")
        
        # Timestamps  
        elif col_name in ['_CreatedDate', '_ModifiedDate', 'CreatedDate', 'ModifiedDate']:
            return (f"ISNULL([{col_name}], CURRENT_TIMESTAMP)", "CURRENT_TIMESTAMP")
        
        # SourceDate special case
        elif col_name in ['_SourceDate', 'SourceDate']:
            return (f"[{col_name}]", "CURRENT_TIMESTAMP")
        
        # Check if expression involves arithmetic (likely numeric)
        elif isinstance(source_expr, (exp.Add, exp.Sub, exp.Mul, exp.Div)):
            return (f"ISNULL([{col_name}], 0)", "0")
        
        # Check for CASE expressions - preserve as is
        elif isinstance(source_expr, exp.Case):
            return (f"[{col_name}]", "0")
        
        # Default: treat as string for safety
        else:
            return (f"ISNULL([{col_name}], '')", "''")
    
    def _get_queries(self, discovered_methods: List[DiscoveredMethod]) -> List[BaseOperation]:
        """Extract and transform operations for silver layer.
        
        Applies silver-specific transformations to Detail tables and handles
        filter-based dimensions. The transformations are already applied in
        _transform_query_result during discovery.
        
        Args:
            discovered_methods: List of discovered methods with metadata and SQL
            
        Returns:
            List[BaseOperation]: List of transformed operations
        """
        # Use the base implementation which creates operations
        # The transformations are already applied to the SQL during discovery
        return super()._get_queries(discovered_methods)